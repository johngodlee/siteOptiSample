---
title: "siteOptiSample"
output: rmarkdown::html_vignette
author: John L. Godlee (johngodlee@gmail.com)
vignette: >
  %\VignetteIndexEntry{siteOptiSample}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,   # wider images
  fig.height = 6,  # taller images
  fig.retina = 2   # higher resolution
)
```

```{r setup}
library(siteOptiSample)

library(dplyr)
library(tidyr)
library(terra)
library(sf)
library(ggplot2)
library(tidyterra)
library(scico)
library(GGally)
library(patchwork)
```

Purpose:

* To what extent are existing plots representative of the broader landscape forest structure? 
* Identify optimal locations for new plots to fill gaps in multidimensional forest structure space.

```{r}

# Import structural metrics raster
data(san_lorenzo_rast)

# Import polygons of existing plots
data(san_lorenzo_plots)

# Prepare data objects
r <- unwrap(san_lorenzo_rast)
p <- san_lorenzo_plots
```


```{r}
# Visualize correlation among structural layers
ggcorr(as.data.frame(r), label = TRUE)
```

The structural metrics are highly correlated.

# Part 1: Test individual functions

Extract metrics from raster for each existing plot. `extractPlotMetrics()` returns a dataframe of values in the same row order as `p`. 

If the structural metrics for each plot are already known, you could skip this step.

```{r}
old_ext <- extractPlotMetrics(r, p, fun = mean)
```

Put pixels and existing plots in the same PCA space. `PCALandscape()` returns two objects with PCA scores, one for pixels (`r_pca`) and one for plots (`p_pca`). `r_pca` is a full PCA object, while `p_pca` is only PCA scores. The PCA is run on variables scaled to unit variance shifted to center on zero. In both `r_pca` and `p_pca`, columns are PCA axes and rows are observations.

```{r}
old_pca <- PCALandscape(r, old_ext, center = TRUE, scale. = TRUE)
```

Calculate distance from each pixel to nearest plot in PCA space. Two methods are available: "euclidean" and "mahalanobis". `pcaDist()` returns vector of distances for each pixel in `r_pca`.


```{r}
old_dist_euclidean <- pcaDist(old_pca$r_pca$x, old_pca$p_pca, 
  n_pca = 3, k = 1, method = "euclidean")

old_dist_mahalanobis <- pcaDist(old_pca$r_pca$x, old_pca$p_pca, 
  n_pca = 3, k = 1, method = "mahalanobis")

old_dist_list <- list(
  "euclidean" = old_dist_euclidean,
  "mahalanobis" = old_dist_mahalanobis)
```

Compare Euclidean and Mahalanobis distances:

```{r}
data.frame(
  euclidean = c(old_dist_euclidean), 
  mahalanobis = c(old_dist_mahalanobis)) %>% 
  ggplot(., aes(x = euclidean, y = mahalanobis)) + 
  geom_abline(linetype = 2, colour = "red") + 
  geom_point(alpha = 0.5) + 
  geom_smooth(colour = "blue") + 
  geom_smooth(method = "lm", colour = "green") + 
  theme_classic() +
  labs(
    x = "Euclidean distance",
    y = "Mahalanobis distance") + 
  ggtitle("Distance in structural space from each pixel to nearest plot")
```

```{r}
data.frame(
  euclidean = c(old_dist_euclidean), 
  mahalanobis = c(old_dist_mahalanobis)) %>% 
  pivot_longer(everything()) %>% 
  ggplot(., aes(x = value, fill = name)) + 
    geom_histogram(position = "identity", alpha = 0.5) + 
    scale_fill_discrete(name = "Distance") + 
    theme_classic() + 
    labs(
      x = "Distance",
      y = "Number of pixels")
```


`pcaDist()` can also be run using a matrix of raw variables. The contribution of individual variables to the distance metric can be weighted using the `w` argument in `pcaDist()`, which is a vector of weights for each variable, corresponding to columns in `x` and `y`:

```{r}
# Prepare matrices with raw variables 
vars_raw <- names(r)[c(1,3,5)]
r_vars_raw <- values(r)[,vars_raw]
old_ext_vars_raw <- old_ext[,vars_raw]

# Run distance function with raw variables
old_dist_raw <- pcaDist(r_vars_raw, old_ext_vars_raw,
  n_pca = 3, k = 1, method = "euclidean")

# Run distance function with weighted raw variables
old_dist_raw_weights <- pcaDist(r_vars_raw, old_ext_vars_raw, w = c(1, 5, 10), 
  n_pca = 3, k = 1, method = "euclidean")

# Compare weighted and unweighted distances
data.frame(
  raw = c(old_dist_raw), 
  raw_weights = c(old_dist_raw_weights)) %>% 
  ggplot(., aes(x = raw, y = raw_weights)) + 
  geom_abline(linetype = 2, colour = "red") + 
  geom_point(alpha = 0.5) + 
  geom_smooth(colour = "blue") + 
  geom_smooth(method = "lm", colour = "green") + 
  theme_classic() +
  labs(
    x = "Distance with unweighted raw data",
    y = "Distance with weighted raw data") + 
  ggtitle("Distance in structural space from each pixel to nearest plot")
```

Create map of the dissimilarity of pixels from existing plots using both distance methods:

```{r}
# Prepare rasters with distances
old_dist_r_list <- lapply(old_dist_list, function(x) { 
  out <- r[[1]]
  values(out)[!is.na(values(out))] <- x
  return(out)
})
names(old_dist_r_list) <- names(old_dist_list)

vis_map_list <- lapply(names(old_dist_r_list), function(x) { 
  ggplot() +
    geom_spatraster(data = old_dist_r_list[[x]]) + 
    scale_fill_scico(name = paste0("Relative distance to nearest plot"), 
      palette = "bamako",
      limits = c(0, 8),
      oob = scales::squish) +
    geom_sf(data = p, 
      colour = "#E74B5E", fill = NA) + 
    guides(
      fill = guide_colourbar(
        title.position = "top",
        barwidth = 20,
        barheight = 1)) + 
    theme_bw() +
    ggtitle(x) +
    labs(
      x = NULL, 
      y = NULL) + 
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "bottom",
      legend.title = element_text(size = 12),
      legend.text = element_text(size = 12))
})
names(vis_map_list) <- names(old_dist_r_list)

wrap_plots(vis_map_list) + 
  plot_layout(
    nrow = 1, 
    guides = "collect") & 
  theme(legend.position = "bottom")
```

Create a PCA biplot of landscape representativeness:

```{r}
# Extract PCA values from r_pca
pca_pt_r <- as.data.frame(old_pca$r_pca$x)
pca_pt_r$type <- "Landscape value" 

# Extract PCA values from p_pca
pca_pt_p <- as.data.frame(old_pca$p_pca)
pca_pt_p$type <- "Existing plot" 

# Combine PCA values
pca_pt_all <- rbind(pca_pt_r, pca_pt_p)
pca_pt_all$type <- factor(pca_pt_all$type, 
  levels = c("Landscape value", "Existing plot"))

ggplot() +
  geom_point(data = pca_pt_all, 
    aes(x = PC1, y = PC2, 
      size = type, colour = type, alpha = type),
      shape = "circle") + 
  scale_colour_discrete(name = NULL) + 
  scale_size_manual(name = NULL, 
    values = c("Landscape value" = 1, "Existing plot" = 3)) + 
  scale_alpha_manual(name = NULL, 
    values = c("Landscape value" = 1, "Existing plot" = 0.5)) + 
  labs(x = "PC1", y = "PC2") + 
  theme_bw() +
  ggtitle("Structural space coverage") +
  theme(plot.title = element_text(hjust = 0.5))
```

Classify pixels by how well-represented they are by the plots, then create a map of pixel classification. `classifLandscape()` returns a dataframe with the distances of each pixel in `r_pca` to its nearest plot in structural space, and its classification as well-represented or poorly represented by the plots, according to the confidence interval threshold provided in argument `ci`. 

```{r}
# Run pixel classification
old_pca_classif <- classifLandscape(
  r_pca = old_pca$r_pca$x, 
  p = old_pca$p_pca, 
  n_pca = 3, 
  ci = 0.95
)

# Prepare raster with pixel classifications
r_classif <- r[[1]]
values(r_classif)[!is.na(values(r_classif))] <- old_pca_classif$group
r_classif_cls <- data.frame(
  id = c(1, 2), 
  classif = c("Poorly represented", "Well-represented by existing plots"))
levels(r_classif) <- r_classif_cls

# Create map of pixels and their classification
ggplot() +
  geom_spatraster(data = r_classif) + 
  scale_fill_discrete(name = NULL, guide = guide_legend(nrow = 3),
    na.value = NA, na.translate = FALSE) +
  theme_bw() +
  ggtitle("Landscape representativeness") +
  labs(
    x = NULL, 
    y = NULL) + 
  theme(
    plot.title = element_text(hjust = 0.5),
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12))
```

Create a PCA biplot of pixel classification:

```{r}
old_pca_classif_df <- as.data.frame(old_pca$r_pca$x)
old_pca_classif_df$group <- old_pca_classif$group

ggplot(old_pca_classif_df, aes(PC1, PC2, colour = group)) +
  geom_point(alpha = 0.8) +
  scale_colour_discrete(name = NULL) +
  theme_bw() + 
  labs(x = "PC1", y = "PC2") + 
  theme(legend.position = "bottom")
```

## Part 2: Optimally locate new plots

The `newPlotSelect()` function optimally locates new plots based on the relative distances of pixels from their nearest plot in structural space.

Two algorithms for locating new plots are available:

The `meanminSelect()` algorithm aims to minimize the mean distance of all pixels to their nearest plot in PCA space, iteratively placing new plots in pixels that most reduce the average pixel-to-nearest-plot distance. For each candidate pixel, compute how adding a plot to that pixel would decrease the mean pixel-to-nearest-plot distance, then choose the pixel that yields the largest decrease in mean distance. As a result, plots concentrate in common areas structural space.


The `minimaxSelect()` algorithm aims to minimise the maximum distance between proposed plots and existing plots, iteratively placing new plots in pixels with structural attributes most dissimilar to existing plots. For each candidate pixel, compute the distance to the nearest existing plot, then choose the pixel with the highest distance value. As a result, plots occupy structural extremes.

The code below runs `newPlotSelect()` with a few different options, then compares how they affect plot placement.

```{r}
# Test with existing plots
test1 <- newPlotSelect(
  r = r,
  p = p,
  n_plots = 10,
  p_new_dim = c(100, 100),
  r_mask = NULL,
  pca = TRUE, 
  n_pca = 3,
  method = meanminSelect)
test1$type <- "With existing plots"

# Test without existing plots
test2 <- newPlotSelect(
  r = r,
  p = NULL,
  n_plots = 10,
  p_new_dim = c(100, 100),
  r_mask = NULL,
  pca = TRUE, 
  n_pca = 3,
  method = meanminSelect)
test2$type <- "Without existing plots"

# Test without PCA 
test3 <- newPlotSelect(
  r = r,
  p = NULL,
  n_plots = 10,
  p_new_dim = c(100, 100),
  r_mask = NULL,
  pca = FALSE, 
  n_pca = NULL,
  method = meanminSelect)
test3$type <- "Using raw raster values"

# Test with PCA using all columns
test4 <- newPlotSelect(
  r = r,
  p = NULL,
  n_plots = 10,
  p_new_dim = c(100, 100),
  r_mask = NULL,
  pca = TRUE, 
  n_pca = 12,
  method = meanminSelect)
test4$type <- "Using all PCA axes"

# Combine tests
test_1_2_3_4 <- list(
  test1,
  test2, 
  test3,
  test4)

# Create a raster to use as a background
r_bg <- r[[1]]
r_bg[!is.na(values(r_bg))] <- 1
r_bg <- as.factor(r_bg)

# Output should be identical
wrap_plots(lapply(test_1_2_3_4, function(x) {
  ggplot() + 
    geom_spatraster(data = r_bg, show.legend = FALSE) +
    scale_fill_manual(values = "grey", na.value = NA, na.translate = FALSE) + 
    geom_sf(data = x, fill = NA, colour = "red") + 
    theme_void() + 
    ggtitle(unique(x$type))
}))
```

A mask layer provided by argument `r_mask` can be used to restrict the location of new plots. You could use this to filter out inaccessible locations, for example.

```{r}
# Test with mask layer
r_mask <- r[[1]]
r_mask[values(r_mask) < 35] <- NA_real_
r_mask[!is.na(values(r_mask))] <- 1
r_mask <- as.factor(r_mask)

test5 <- newPlotSelect(
  r = r,
  p = NULL,
  n_plots = 10,
  p_new_dim = c(100, 100),
  r_mask = r_mask,
  pca = TRUE, 
  n_pca = 3,
  method = meanminSelect)
test5$type <- "Using a mask layer"

# Should always overlap mask layer   
ggplot() + 
  geom_spatraster(data = r_mask, show.legend = FALSE) + 
  scale_fill_manual(values = "grey", na.value = NA, na.translate = FALSE) + 
  geom_sf(data = test5, colour = "red", fill = NA) +
  theme_classic()
```

Comparison of the `meanminSelect()` and `minimaxSelect()` algorithms:

```{r}
# Test with minimax algorithm
test6 <- newPlotSelect(
  r = r,
  p = p,
  n_plots = 10,
  p_new_dim = c(100, 100),
  r_mask = NULL,
  pca = TRUE, 
  n_pca = 3,
  method = minimaxSelect)
test6$type <- "minimax"

test_1_6 <- list(
  test1, 
  test6)
test_1_6[[1]]$type <- "meanmin"

wrap_plots(lapply(test_1_6, function(x) {
  ggplot() + 
    geom_spatraster(data = r_bg, show.legend = FALSE) +
    scale_fill_manual(values = "grey", na.value = NA, na.translate = FALSE) + 
    geom_sf(data = x, fill = NA, colour = "red") + 
    theme_void() + 
    ggtitle(unique(x$type))
}))
```

```{r}
# Compare PCA positions using minimax and meanmin algorithms

# Extract metrics from raster for each existing plot
test1_ext <- extractPlotMetrics(r, test1, fun = NULL)
test6_ext <- extractPlotMetrics(r, test6, fun = NULL)
# Using FUN = NULL returns the values of all values within each pixel

# Put pixels and existing plots in the same PCA space
test1_pca <- as.data.frame(PCALandscape(r, test1_ext, center = TRUE, scale. = TRUE)$p_pca)
test1_pca$type <- "meanmin"
test6_pca <- as.data.frame(PCALandscape(r, test6_ext, center = TRUE, scale. = TRUE)$p_pca)
test6_pca$type <- "minimax"

pca_pt_test_1_6 <- rbind(pca_pt_r, test1_pca, test6_pca, pca_pt_p)
pca_pt_test_1_6$type <- factor(pca_pt_test_1_6$type,
  levels = c("Landscape value", "meanmin", "minimax", "Existing plot"))

ggplot() +
  geom_point(data = pca_pt_test_1_6, 
    aes(x = PC1, y = PC2, 
      size = type, colour = type, alpha = type),
      shape = "circle") + 
  scale_colour_discrete(name = NULL) + 
  scale_size_manual(name = NULL, 
    values = c("Existing plot" = 3, "meanmin" = 3, "minimax" = 3, "Landscape value" = 1)) + 
  scale_alpha_manual(name = NULL, 
    values = c("Existing plot" = 0.5, "meanmin" = 0.5, "minimax" = 0.5, "Landscape value" = 1)) + 
  labs(x = "PC1", y = "PC2") + 
  theme_bw() +
  ggtitle("Structural space coverage") +
  theme(plot.title = element_text(hjust = 0.5))
```

```{r}
# Calculate distance from each pixel to nearest plot in PCA space
# Using meanmin and minimax algorithms
test1_dist_euclidean <- pcaDist(old_pca$r_pca$x, 
  as.matrix(test1_pca[,grepl("PC", colnames(test1_pca))]), 
  n_pca = 3, k = 1, method = "euclidean")

test6_dist_euclidean <- pcaDist(old_pca$r_pca$x, 
  as.matrix(test6_pca[,grepl("PC", colnames(test6_pca))]), 
  n_pca = 3, k = 1, method = "euclidean")
 
# Create histograms to compare resulting distances
data.frame(
  existing = c(old_dist_euclidean), 
  meanmin = c(test1_dist_euclidean),
  minimax = c(test6_dist_euclidean)) %>% 
  pivot_longer(everything()) %>% 
  mutate(name = factor(name, 
    levels = c("existing", "meanmin", "minimax"),
    labels = c("Existing plot", "meanmin", "minimax"))) %>% 
  ggplot(., aes(x = value, fill = name)) + 
    geom_histogram(position = "identity", colour = "black") + 
    facet_wrap(~name, scales = "fixed", ncol = 1) + 
    theme_classic() + 
    theme(legend.position = "none") + 
    labs(
      x = "Distance",
      y = "Number of pixels")
```

